# Simple MCP Server Implementation Guide

This guide provides instructions for setting up a simple Model Context Protocol (MCP) server that can be used with Claude Desktop or other MCP clients.

## Overview

The Model Context Protocol (MCP) server implemented here provides basic functionality for:
- Managing conversations
- Storing messages
- Handling completion requests (with simulated responses)

This is intended as a demonstration and learning tool, not a production-ready implementation.

## Prerequisites

- Python 3.6+
- pip (Python package manager)

## Setup Instructions

### Step 1: Install Dependencies

```bash
pip install flask
```

### Step 2: Save the Server Code

Save the Python code below to a file named `mcp_server.py`:

```python
from flask import Flask, request, jsonify
import uuid
import json
import logging
from datetime import datetime

app = Flask(__name__)
logging.basicConfig(level=logging.INFO)

# In-memory storage for conversations and messages
conversations = {}
messages = {}

@app.route("/api/mcp/v1/conversations", methods=["POST"])
def create_conversation():
    conversation_id = str(uuid.uuid4())
    conversations[conversation_id] = {
        "id": conversation_id,
        "created_at": datetime.now().isoformat(),
        "updated_at": datetime.now().isoformat(),
        "title": "New Conversation",
        "metadata": {}
    }
    
    logging.info(f"Created conversation: {conversation_id}")
    return jsonify(conversations[conversation_id]), 201

@app.route("/api/mcp/v1/conversations", methods=["GET"])
def list_conversations():
    return jsonify(list(conversations.values())), 200

@app.route("/api/mcp/v1/conversations/<conversation_id>", methods=["GET"])
def get_conversation(conversation_id):
    if conversation_id not in conversations:
        return jsonify({"error": "Conversation not found"}), 404
    
    return jsonify(conversations[conversation_id]), 200

@app.route("/api/mcp/v1/conversations/<conversation_id>/messages", methods=["POST"])
def create_message(conversation_id):
    if conversation_id not in conversations:
        return jsonify({"error": "Conversation not found"}), 404
    
    data = request.get_json()
    
    # Validate request
    if "role" not in data or "content" not in data:
        return jsonify({"error": "Missing required fields"}), 400
    
    message_id = str(uuid.uuid4())
    messages[message_id] = {
        "id": message_id,
        "conversation_id": conversation_id,
        "created_at": datetime.now().isoformat(),
        "role": data["role"],
        "content": data["content"],
        "metadata": data.get("metadata", {})
    }
    
    # Update conversation
    conversations[conversation_id]["updated_at"] = datetime.now().isoformat()
    
    logging.info(f"Created message: {message_id} in conversation: {conversation_id}")
    return jsonify(messages[message_id]), 201

@app.route("/api/mcp/v1/conversations/<conversation_id>/messages", methods=["GET"])
def list_messages(conversation_id):
    if conversation_id not in conversations:
        return jsonify({"error": "Conversation not found"}), 404
    
    # Filter messages by conversation_id
    conversation_messages = [msg for msg in messages.values() if msg["conversation_id"] == conversation_id]
    return jsonify(conversation_messages), 200

@app.route("/api/mcp/v1/completions", methods=["POST"])
def create_completion():
    data = request.get_json()
    
    # Validate request
    if "conversation_id" not in data or "messages" not in data:
        return jsonify({"error": "Missing required fields"}), 400
    
    conversation_id = data["conversation_id"]
    if conversation_id not in conversations:
        return jsonify({"error": "Conversation not found"}), 404
    
    # Here you would normally process the messages and generate a response
    # For this demo, we'll just echo back a simple response
    
    message_id = str(uuid.uuid4())
    response_message = {
        "id": message_id,
        "conversation_id": conversation_id,
        "created_at": datetime.now().isoformat(),
        "role": "assistant",
        "content": "This is a simulated response from the MCP server. In a real implementation, this would be generated by an AI model.",
        "metadata": {}
    }
    
    # Store the message
    messages[message_id] = response_message
    
    # Update conversation
    conversations[conversation_id]["updated_at"] = datetime.now().isoformat()
    
    logging.info(f"Created completion message: {message_id} in conversation: {conversation_id}")
    return jsonify(response_message), 201

if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=5000)
```

### Step 3: Run the Server

```bash
python mcp_server.py
```

This will start the server on `http://localhost:5000`.

## Connecting with Claude Desktop

1. Open Claude Desktop
2. Go to Settings
3. Look for the "Custom MCP Server" option
4. Enter `http://localhost:5000` as the server URL
5. Save your settings

## API Endpoints

This implementation provides the following endpoints:

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/mcp/v1/conversations` | POST | Create a new conversation |
| `/api/mcp/v1/conversations` | GET | List all conversations |
| `/api/mcp/v1/conversations/<conversation_id>` | GET | Get a specific conversation |
| `/api/mcp/v1/conversations/<conversation_id>/messages` | POST | Add a message to a conversation |
| `/api/mcp/v1/conversations/<conversation_id>/messages` | GET | List messages in a conversation |
| `/api/mcp/v1/completions` | POST | Generate a completion (simulated) |

## Limitations

This simple implementation has several limitations:
- No authentication or security measures
- In-memory storage (data is lost when the server restarts)
- No actual AI model integration (responses are simulated)
- Limited error handling
- No conversation title management

## Next Steps for Enhancement

To enhance this implementation, consider:
- Adding authentication (e.g., API keys)
- Implementing persistent storage (database)
- Connecting to an actual AI model API
- Adding more robust error handling
- Implementing conversation title updates